<beginfold id='1'></beginfold id='1'><beginfold id='3'>/*</beginfold id='3'> This test file tests kates Lex/Flex highlighting <endfold id='3'>*/</endfold id='3'>

%option c++
%option yyclass="KateTester"
%option yylineno

 <beginfold id='9'>/*</beginfold id='9'> This is a C(++) comment <endfold id='9'>*/</endfold id='9'>

<beginfold id='3'>/*</beginfold id='3'> This one is a lex comment ! <endfold id='3'>*/</endfold id='3'>

<beginfold id='6'>%{</beginfold id='6'>
#include <iostream>
#include "realparser.hpp"
using namespace std;
<endfold id='6'>%}</endfold id='6'>

<beginfold id='3'>/*</beginfold id='3'> Some definitions <endfold id='3'>*/</endfold id='3'>
DIGIT    [0-9]
LETTER   [_a-zA-Z]

<endfold id='1'></endfold id='1'><beginfold id='2'>%%</beginfold id='2'>

 <beginfold id='9'>/*</beginfold id='9'> Comment *shall be indented here* <endfold id='9'>*/</endfold id='9'>
[ \t\n\r]+          

 <beginfold id='9'>/*</beginfold id='9'> Note: there is a bad } just here     vvv <endfold id='9'>*/</endfold id='9'>
\/\*([^\*]|\*[^/])*\*\/ <beginfold id='7'>{</beginfold id='7'> foo(a, b, c); <endfold id='7'>}</endfold id='7'> }

 <beginfold id='9'>/*</beginfold id='9'> A start condition scope... <endfold id='9'>*/</endfold id='9'>
<ESC><beginfold id='5'>{</beginfold id='5'>
  "a" <beginfold id='7'>{</beginfold id='7'>
  
  <beginfold id='9'>/*</beginfold id='9'> C mode ! <endfold id='9'>*/</endfold id='9'>
  return 0;
<endfold id='7'>}</endfold id='7'>

  "b" <beginfold id='6'>%{</beginfold id='6'>
  
  <beginfold id='9'>/*</beginfold id='9'> C mode, too ! <endfold id='9'>*/</endfold id='9'>
  return 0;
<endfold id='6'>%}</endfold id='6'>
  
  "c" return 0; // C++ comment
<endfold id='5'>}</endfold id='5'>

 <beginfold id='9'>/*</beginfold id='9'> Big rule <endfold id='9'>*/</endfold id='9'>
\"([^"\\]|\\.)*\" <beginfold id='7'>{</beginfold id='7'>

   yylval.string_val = new char[strlen(yytext) + 1];
   int j = 0, i = 1;
   
   while (yytext[i] != '"')
      if (yytext[i] != '\\')
         yylval.string_val[j++] = yytext[i++];
      else
         switch (yytext[i + 1])
         <beginfold id='7'>{</beginfold id='7'>
         case 'n':
            yylval.string_val[j++] = '\n'; i += 2;
            break;
         default:
            yylval.string_val[j++] << yytext[i + 1], i += 2;
         <endfold id='7'>}</endfold id='7'>
    
    yylval.string_val[j] = 0;   
    return TOK_STRING;

<endfold id='7'>}</endfold id='7'>

 <beginfold id='9'>/*</beginfold id='9'> Dot (match all) <endfold id='9'>*/</endfold id='9'>
.             <beginfold id='7'>{</beginfold id='7'>return yylval.int_val = yytext[0];<endfold id='7'>}</endfold id='7'>

<endfold id='2'></endfold id='2'><beginfold id='4'>%%</beginfold id='4'>

// Here is pure C(++)
#include <iostream>

int main(void)
<beginfold id='8'>{</beginfold id='8'>
  std::cout << "Hello, World\n";
  return 0;
<endfold id='8'>}</endfold id='8'>
